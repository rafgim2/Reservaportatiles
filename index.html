<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RESERVA DE PORTÁTILES</title>
  <style>
    :root {
      --col-date-width: 110px;
      --col-session-width: 90px;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
    }

    .top-bar {
      position: sticky;
      top: 0;
      z-index: 50;
      background: #f5f5f5;
    }

    header {
      background: #1f4e79;
      color: white;
      padding: 16px 24px 10px;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 1px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      padding: 8px 24px 6px;
      background: #f5f5f5;
    }

    main {
      padding: 12px 16px 24px;
    }

    label {
      font-weight: 600;
    }

    select {
      padding: 4px 8px;
      font-size: 14px;
    }

    .legend {
      font-size: 12px;
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid #aaa;
    }

    .legend-color.free {
      background: #ffffff;
    }

    .legend-color.partial {
      background: #e8f5e9; /* reservas parciales: aún quedan portátiles */
    }

    .legend-color.reserved {
      background: #e53935; /* franja completa, sin portátiles */
    }

    .table-container {
      max-width: 100%;
      overflow: auto;        /* scroll horizontal y vertical */
      border: 1px solid #ccc;
      background: white;
      border-radius: 4px;
      max-height: 80vh;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 900px;
      font-size: 12px;
      table-layout: fixed;
    }

    thead {
      background: #e1e9f2;
    }

    /* Bordes y fondo por defecto de TODAS las celdas */
    th,
    td {
      border: 1px solid #ccc;
      padding: 4px 6px;
      text-align: center;
      white-space: normal;
      word-break: break-word;
      background: #ffffff; /* Todo libre en blanco por defecto */
    }

    /* Cabecera fija arriba (todas las columnas) */
    thead th {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #dde3ff;
    }

    /* Ancho fijo para columnas Fecha y Sesión */
    thead th:nth-child(1),
    tbody td:nth-child(1) {
      width: var(--col-date-width);
      min-width: var(--col-date-width);
      max-width: var(--col-date-width);
    }

    thead th:nth-child(2),
    tbody td:nth-child(2) {
      width: var(--col-session-width);
      min-width: var(--col-session-width);
      max-width: var(--col-session-width);
    }

    /* Nueva columna: portátiles disponibles (3ª) */
    thead th:nth-child(3),
    tbody td:nth-child(3) {
      width: 110px;
      min-width: 110px;
      max-width: 110px;
    }

    /* Primera columna (Fecha) fija a la izquierda */
    thead th:nth-child(1) {
      position: sticky;
      left: 0;
      z-index: 20;
      background: #dde3ff;
    }

    /* Segunda columna (Sesión) fija detrás de la de Fecha */
    thead th:nth-child(2) {
      position: sticky;
      left: var(--col-date-width);
      z-index: 20;
      background: #dde3ff;
    }

    /* Celdas de cuerpo: Fecha y Sesión fijas a la izquierda al hacer scroll horizontal */
    tbody td:nth-child(1) {
      position: sticky;
      left: 0;
      z-index: 15;
      background: #fff;
    }

    tbody td:nth-child(2) {
      position: sticky;
      left: var(--col-date-width);
      z-index: 15;
      background: #fff;
    }

    /* Separador grueso entre días (primera fila de cada día) */
    tbody tr.first-slot-of-day td {
      border-top-width: 3px;
    }

    /* - row-partial-reservation → hay reservas pero aún quedan portátiles (verde suave)
       - row-full-reservation    → franja completa, 0 disponibles (rojo suave)
    */
    tbody tr.row-partial-reservation td {
      background: #e8f5e9; /* verde muy suave */
    }

    tbody tr.row-full-reservation td {
      background: #ffebee; /* rojo suave */
    }

    td.reservable {
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease;
      position: relative;
      overflow: hidden;
    }

    td.reservable:hover {
      box-shadow: inset 0 0 0 2px #1f4e79;
    }

    td.reserved {
      background: #e53935 !important;
      color: #ffffff;
      font-weight: 700;
    }

    /* Reservas fijas del horario (no clicables) */
    td.fixed-reserved {
      background: #b71c1c !important;
      color: #ffffff;
      font-weight: 700;
      cursor: default;
    }

    td.reservable::before {
      content: attr(data-class);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 10px;
      color: rgba(0, 0, 0, 0.25);
      pointer-events: none;
      text-align: center;
      width: 100%;
      padding: 0 4px;
      box-sizing: border-box;
      line-height: 1.2;
    }

    /* Cuando está reservada, mostramos también la cantidad: "4ºA (10)" */
    td.reserved::before {
      content: attr(data-class) " (" attr(data-count) ")";
      color: rgba(255, 255, 255, 0.9);
      font-weight: 700;
    }

    /* Reservas fijas → siempre se muestra "(25)" */
    td.fixed-reserved::before {
      content: attr(data-class) " (25)";
      color: rgba(255, 255, 255, 0.7);
      font-weight: 700;
    }

    /* Celda de fecha del día actual (barra verde) */
    .today-date-cell {
      background: #c8e6c9 !important;
      border-left: 8px solid #2e7d32;
      font-weight: 700;
    }

    .info {
      font-size: 11px;
      color: #555;
      margin-top: 6px;
    }
  </style>
</head>
<body>
  <!-- Barra superior fija -->
  <div class="top-bar">
    <header>
      <h1>RESERVA CARRO DE PORTÁTILES</h1>
    </header>

    <div class="controls">
      <div>
        <label for="monthSelect">Mes:</label>
        <select id="monthSelect"></select>
      </div>
      <div class="legend">
        <span class="legend-item">
          <span class="legend-color free"></span> Libre
        </span>
        <span class="legend-item">
          <span class="legend-color partial"></span> Reservado (quedan portátiles)
        </span>
        <span class="legend-item">
          <span class="legend-color reserved"></span> Sin portátiles disponibles
        </span>
        <span>Haz doble clic o doble toque para reservar / liberar.</span>
      </div>
    </div>
  </div>

  <main>
    <div class="table-container">
      <table id="calendarTable">
        <!-- Cabecera y cuerpo se generan por JS -->
      </table>
    </div>

    <p class="info">
      * Las reservas pueden cambiarse o cancelarse durante un máximo de 2 minutos desde el momento en que se realizan.
    </p>
    <p class="info"></p>
  </main>

  <!-- JS con Firestore -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import {
      getFirestore,
      doc,
      onSnapshot,
      setDoc,
      deleteField
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

    // ⏱ TIEMPO MÁXIMO PARA DESHACER (ms) → ahora 2 minutos
    const UNRESERVE_WINDOW_MS = 2 * 60 * 1000;

    // ⏱ TIEMPO MÁXIMO DE BLOQUEO POR DISPOSITIVO (24h)
    const USER_RESERVATION_TTL_MS = 24 * 60 * 60 * 1000;

    const firebaseConfig = {
      apiKey: "AIzaSyD5EAMg-0p54f8bPq8SVdZ_ePg5Xso3cmg",
      authDomain: "arm1-acbba.firebaseapp.com",
      projectId: "arm1-acbba",
      storageBucket: "arm1-acbba.firebasestorage.app",
      messagingSenderId: "408825932019",
      appId: "1:408825932019:web:10f2079b590b4c9ca3af86",
      measurementId: "G-S78TM6PVRL"
    };

    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    const months = [
      { year: 2025, month: 11, name: "Noviembre 2025" },
      { year: 2025, month: 12, name: "Diciembre 2025" },
      { year: 2026, month: 1, name: "Enero 2026" },
      { year: 2026, month: 2, name: "Febrero 2026" },
      { year: 2026, month: 3, name: "Marzo 2026" },
      { year: 2026, month: 4, name: "Abril 2026" },
      { year: 2026, month: 5, name: "Mayo 2026" },
      { year: 2026, month: 6, name: "Junio 2026" }
    ];

    const classes = [
      "Infantil 3 años",
      "Infantil 4 años",
      "Infantil 5 años",
      "1ºA",
      "2ºA",
      "3ºA",
      "4ºA",
      "4ºB",
      "5ºA",
      "5ºB",
      "6ºA",
      "6ºB"
    ];

    // Nº total de portátiles del carro
    const MAX_LAPTOPS = 25;

    // Horarios normales (nov–may)
    const defaultSlots = [
      "9:00-9:45",   // 1ª
      "9:45-10:30",  // 2ª
      "10:30-11:15", // 3ª
      "11:45-12:30", // 4ª
      "12:30-13:15", // 5ª
      "13:15-14:00"  // 6ª
    ];

    // Horarios especiales para JUNIO 2026 (solo 5 sesiones)
    const juneSlots = [
      "9:00-9:40",
      "9:40-10:20",
      "10:20-11:00",
      "11:30-12:15",
      "12:15-13:00"
    ];

    function getSlotsForMonth(monthIndex) {
      const { year, month } = months[monthIndex];
      if (year === 2026 && month === 6) {
        return juneSlots;
      }
      return defaultSlots;
    }

    /* === RESERVAS FIJAS SEGÚN LA FOTO DEL HORARIO === */
    const FIXED_WEEKLY_RESERVATIONS = [
      { weekday: 5, session: 1, className: "3ºA" }, // 1ª Viernes 3A
      { weekday: 4, session: 4, className: "5ºA" }, // 4ª Jueves 5A
      { weekday: 5, session: 4, className: "1ºA" }, // 4ª Viernes 1A
      { weekday: 4, session: 5, className: "4ºA" }, // 5ª Jueves 4A
      { weekday: 3, session: 6, className: "6ºB" }, // 6ª Miércoles 6B
      { weekday: 4, session: 6, className: "6ºA" }, // 6ª Jueves 6A
      { weekday: 5, session: 6, className: "5ºB" }  // 6ª Viernes 5B
    ];

    function isFixedReservation(dateIso, slot, className) {
      const d = new Date(dateIso);
      const weekday = d.getDay(); // 0=Dom,1=Lun,…,5=Vie
      if (weekday < 1 || weekday > 5) return false;

      const slotsForMonth = getSlotsForMonth(currentMonthIndex);
      const idx = slotsForMonth.indexOf(slot);
      if (idx === -1) return false;
      const session = idx + 1;

      return FIXED_WEEKLY_RESERVATIONS.some(
        r => r.weekday === weekday && r.session === session && r.className === className
      );
    }

    // Devuelve si una franja (fecha+slot) está ocupada por una reserva fija, aunque sea otra clase
    function getFixedReservationForSlot(dateIso, slot) {
      const d = new Date(dateIso);
      const weekday = d.getDay();
      if (weekday < 1 || weekday > 5) return null;

      const slotsForMonth = getSlotsForMonth(currentMonthIndex);
      const idx = slotsForMonth.indexOf(slot);
      if (idx === -1) return null;
      const session = idx + 1;

      const r = FIXED_WEEKLY_RESERVATIONS.find(
        x => x.weekday === weekday && x.session === session
      );
      return r || null;
    }

    function parseReservationValue(val) {
      if (!val) return null;

      if (typeof val === "object") {
        const t = typeof val.time === "number" ? val.time : null;
        const c = typeof val.count === "number" ? val.count : 1;
        return { time: t, count: c };
      }

      if (typeof val === "number") {
        return { time: val, count: 1 };
      }

      if (val === true) {
        return { time: null, count: 1 };
      }

      return null;
    }

    function getReservedCountForSlot(dateIso, slot) {
      const fixed = getFixedReservationForSlot(dateIso, slot);
      if (fixed) return MAX_LAPTOPS;

      const prefix = `${dateIso}__${slot}__`;
      let total = 0;

      for (const key in currentData) {
        const val = currentData[key];
        const info = parseReservationValue(val);
        if (!info) continue;
        if (key.startsWith(prefix)) {
          const n = info.count && info.count > 0 ? info.count : 1;
          total += n;
        }
      }

      return total;
    }

    function getAvailabilityForSlot(dateIso, slot) {
      const reserved = getReservedCountForSlot(dateIso, slot);
      const remaining = Math.max(MAX_LAPTOPS - reserved, 0);
      return { reserved, remaining };
    }

    function pedirCantidadPortatiles(max, valorPorDefecto = 1) {
      const mensaje = `¿Cuántos portátiles quieres reservar? (1–${max})`;
      const respuesta = prompt(mensaje, String(valorPorDefecto));
      if (respuesta === null) return null;

      const n = parseInt(respuesta, 10);
      if (!Number.isFinite(n) || n < 1 || n > max) {
        alert(`Introduce un número entre 1 y ${max}.`);
        return null;
      }

      return n;
    }

    const monthSelect    = document.getElementById("monthSelect");
    const calendarTable  = document.getElementById("calendarTable");
    const tableContainer = document.querySelector(".table-container");

    let currentMonthIndex = 0;
    let currentData = {};
    let unsubscribe = null;

    const autoScrolledMonths = {};

    function getCurrentDocId() {
      const { year, month } = months[currentMonthIndex];
      return `${year}-${String(month).padStart(2, "0")}`;
    }

    function monthDocRef(monthIndex) {
      const { year, month } = months[monthIndex];
      const id = `${year}-${String(month).padStart(2, "0")}`;
      return doc(db, "reservas_portatiles_celdas", id);
    }

    function buildReservationId(dateIso, slot, className) {
      return `${dateIso}__${slot}__${className}`;
    }

    function subscribeToMonth(monthIndex) {
      if (unsubscribe) {
        unsubscribe();
        unsubscribe = null;
      }
      currentMonthIndex = monthIndex;

      const ref = monthDocRef(monthIndex);
      unsubscribe = onSnapshot(ref, (snap) => {
        currentData = snap.exists() ? snap.data() : {};
        renderMonth(monthIndex);
      });
    }

    async function setReservationValue(id, value) {
      const ref = monthDocRef(currentMonthIndex);
      const update = {};
      update[id] = value;
      await setDoc(ref, update, { merge: true });
    }

    async function clearReservation(id) {
      const ref = monthDocRef(currentMonthIndex);
      const update = {};
      update[id] = deleteField();
      await setDoc(ref, update, { merge: true });
    }

    // ➜ CONTROL POR USUARIO:
    const LOCAL_USER_RES_KEY = "reservas_portatiles_mis_reservas_por_semana";

    function getWeekKeyFromIso(dateIso) {
      const [year, month, day] = dateIso.split("-").map(Number);
      const date = new Date(year, month - 1, day);
      const { isoYear, week } = getISOYearWeek(date);
      return `${isoYear}-W${String(week).padStart(2, "0")}`;
    }

    function getISOYearWeek(date) {
      const tmp = new Date(date.valueOf());
      const dayNr = (tmp.getDay() + 6) % 7;
      tmp.setDate(tmp.getDate() - dayNr + 3);

      const isoYear = tmp.getFullYear();

      const jan4 = new Date(isoYear, 0, 4);
      const jan4Day = (jan4.getDay() + 6) % 7;
      jan4.setDate(jan4.getDate() - jan4Day + 3);

      const week = 1 + Math.round((tmp - jan4) / 604800000);
      return { isoYear, week };
    }

    function getUserReservationsMap() {
      try {
        const raw = localStorage.getItem(LOCAL_USER_RES_KEY);
        if (!raw) return {};
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object" || Array.isArray(obj)) return {};
        return obj;
      } catch {
        return {};
      }
    }

    function saveUserReservationsMap(map) {
      try {
        localStorage.setItem(LOCAL_USER_RES_KEY, JSON.stringify(map));
      } catch {}
    }

    function getUserReservationInfoForWeek(weekKey) {
      const map = getUserReservationsMap();
      const now = Date.now();
      let changed = false;

      for (const wk in map) {
        const info = map[wk];
        if (!info || typeof info.time !== "number") {
          delete map[wk];
          changed = true;
          continue;
        }
        if (now - info.time > USER_RESERVATION_TTL_MS) {
          delete map[wk];
          changed = true;
        }
      }

      if (changed) saveUserReservationsMap(map);
      return map[weekKey] || null;
    }

    function addUserReservationForWeek(weekKey, fullId, time) {
      const map = getUserReservationsMap();
      map[weekKey] = { fullId, time };
      saveUserReservationsMap(map);
    }

    function removeUserReservationByFullId(fullId) {
      const map = getUserReservationsMap();
      let changed = false;
      for (const wk in map) {
        if (map[wk] && map[wk].fullId === fullId) {
          delete map[wk];
          changed = true;
        }
      }
      if (changed) saveUserReservationsMap(map);
    }

    function buildFullReservationId(id) {
      const docId = getCurrentDocId();
      return `${docId}::${id}`;
    }

    function getTodayIso() {
      const now = new Date();
      const y = now.getFullYear();
      const m = String(now.getMonth() + 1).padStart(2, "0");
      const d = String(now.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    function getInitialMonthIndex() {
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth() + 1;

      const idx = months.findIndex(m => m.year === year && m.month === month);
      return idx === -1 ? 0 : idx;
    }

    months.forEach((m, index) => {
      const opt = document.createElement("option");
      opt.value = index;
      opt.textContent = m.name;
      monthSelect.appendChild(opt);
    });

    monthSelect.addEventListener("change", () => {
      const idx = parseInt(monthSelect.value, 10);
      subscribeToMonth(idx);
    });

    function getWeekdays(year, month) {
      const days = [];
      const date = new Date(year, month - 1, 1);
      const initials = { 1: "L", 2: "M", 3: "X", 4: "J", 5: "V" };

      while (date.getMonth() === month - 1) {
        const day = date.getDay();
        if (day >= 1 && day <= 5) {
          const d = String(date.getDate()).padStart(2, "0");
          const m = String(month).padStart(2, "0");
          const y = year;
          const initial = initials[day] || "";
          days.push({
            iso: `${y}-${m}-${d}`,
            label: `${initial} ${d}/${m}/${y}`
          });
        }
        date.setDate(date.getDate() + 1);
      }
      return days;
    }

    function renderMonth(monthIndex) {
      const { year, month } = months[monthIndex];
      const days = getWeekdays(year, month);
      const slotsForMonth = getSlotsForMonth(monthIndex);
      const saved = currentData || {};
      const todayIso = getTodayIso();

      calendarTable.innerHTML = "";

      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      const labels = ["Fecha", "Sesión", "Portátiles disp.", ...classes];
      labels.forEach(text => {
        const th = document.createElement("th");
        th.textContent = text;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      calendarTable.appendChild(thead);

      const tbody = document.createElement("tbody");
      let todayAnchorRow = null;

      days.forEach(day => {
        const isToday = (day.iso === todayIso);
        const isPastDay = (day.iso < todayIso);

        slotsForMonth.forEach((slot, slotIndex) => {
          const tr = document.createElement("tr");

          if (slotIndex === 0) tr.classList.add("first-slot-of-day");

          const tdFecha = document.createElement("td");
          tdFecha.textContent = day.label;
          if (isToday) tdFecha.classList.add("today-date-cell");
          tr.appendChild(tdFecha);

          const tdSlot = document.createElement("td");
          tdSlot.textContent = slot;
          tr.appendChild(tdSlot);

          // ✅ Reservado real (NO inflamos a 25)
          let reservedInSlot = getReservedCountForSlot(day.iso, slot);

          // ✅ Si es pasado: NO se puede reservar -> disponibles 0, y franja en rojo clarito
          let availableInSlot = isPastDay ? 0 : Math.max(MAX_LAPTOPS - reservedInSlot, 0);

          const tdAvail = document.createElement("td");
          tdAvail.textContent = availableInSlot;
          tr.appendChild(tdAvail);

          // Pintado de franja:
          // - Si es pasado => siempre rojo clarito (como "sin portátiles")
          // - Si no es pasado => según disponibilidad real
          const hasReservationInSlot = isPastDay ? true : (reservedInSlot > 0);
          const isFullSlot = isPastDay ? true : (hasReservationInSlot && availableInSlot === 0);

          classes.forEach(cls => {
            const td = document.createElement("td");
            td.classList.add("reservable");
            td.dataset.date = day.iso;
            td.dataset.slot = slot;
            td.dataset.class = cls;

            const id = buildReservationId(day.iso, slot, cls);
            const isFixed = isFixedReservation(day.iso, slot, cls);
            const info = parseReservationValue(saved[id]);

            if (isFixed) {
              td.classList.add("fixed-reserved");
              td.dataset.fixed = "true";
              td.dataset.count = MAX_LAPTOPS;
              td.title = `${cls}: ${MAX_LAPTOPS} portátiles reservados (fijo)`;
            } else if (info) {
              td.classList.add("reserved");
              const n = info.count && info.count > 0 ? info.count : 1;
              td.dataset.count = n;
              td.title = `${cls}: ${n} portátiles reservados`;
            }

            tr.appendChild(td);
          });

          if (hasReservationInSlot) {
            if (isFullSlot) {
              tr.classList.add("row-full-reservation");      // rojo suave
            } else {
              tr.classList.add("row-partial-reservation");   // verde suave
            }
          }

          if (isToday && slotIndex === 0) {
            todayAnchorRow = tr;
          }

          tbody.appendChild(tr);
        });
      });

      calendarTable.appendChild(tbody);

      if (todayAnchorRow && tableContainer) {
        const docId = `${year}-${String(month).padStart(2, "0")}`;
        if (!autoScrolledMonths[docId]) {
          const rowOffset = todayAnchorRow.offsetTop;
          const rowHeight = todayAnchorRow.offsetHeight;
          const targetScrollTop = rowOffset - (tableContainer.clientHeight / 2 - rowHeight / 2);
          tableContainer.scrollTop = Math.max(targetScrollTop, 0);
          autoScrolledMonths[docId] = true;
        }
      }
    }

    const DOUBLE_CLICK_MS = 400;
    let lastCellId = null;
    let lastClickTime = 0;

    async function activarCelda(cell) {
      if (cell.dataset.fixed === "true") {
        alert("Esta franja horaria está reservada de forma fija en el horario y no se puede modificar.");
        return;
      }

      const { date, slot, class: className } = cell.dataset;
      const id = buildReservationId(date, slot, className);
      const fullId = buildFullReservationId(id);

      const value = currentData[id];
      const now   = Date.now();

      if (!value) {
        const todayIso = getTodayIso();
        if (date < todayIso) {
          alert("No se pueden hacer nuevas reservas en días que ya han pasado.");
          return;
        }

        const weekKey = getWeekKeyFromIso(date);
        let userInfo = getUserReservationInfoForWeek(weekKey);

        if (userInfo) {
          const [docId, resId] = userInfo.fullId.split("::");
          if (docId === getCurrentDocId()) {
            const stillExists = currentData && currentData[resId];
            if (!stillExists) {
              removeUserReservationByFullId(userInfo.fullId);
              userInfo = null;
            }
          }
        }

        const fixed = getFixedReservationForSlot(date, slot);
        if (fixed) {
          alert(`Esta franja horaria está asignada de forma fija a ${fixed.className} y no se puede reservar.`);
          return;
        }

        const { remaining } = getAvailabilityForSlot(date, slot);
        if (remaining <= 0) {
          alert("En esta franja ya no quedan portátiles disponibles.");
          return;
        }

        const cantidad = pedirCantidadPortatiles(remaining);
        if (cantidad === null) return;

        await setReservationValue(id, { time: now, count: cantidad });

        const newWeekKey = getWeekKeyFromIso(date);
        addUserReservationForWeek(newWeekKey, fullId, now);
        return;
      }

      const resInfo = parseReservationValue(value);
      if (!resInfo) {
        alert("Esta reserva tiene un formato desconocido y no se puede modificar desde aquí.");
        return;
      }

      const t = resInfo.time;

      if (t === null) {
        await clearReservation(id);
        removeUserReservationByFullId(fullId);
        return;
      }

      const elapsed = now - t;
      if (elapsed <= UNRESERVE_WINDOW_MS) {
        await clearReservation(id);
        removeUserReservationByFullId(fullId);
      } else {
        alert("Esta reserva ya no se puede modificar.");
      }
    }

    calendarTable.addEventListener("click", (event) => {
      const cell = event.target.closest("td.reservable");
      if (!cell) return;

      const uniqueId = `${cell.dataset.date}__${cell.dataset.slot}__${cell.dataset.class}`;
      const now = Date.now();

      if (lastCellId === uniqueId && (now - lastClickTime) <= DOUBLE_CLICK_MS) {
        activarCelda(cell);
        lastCellId = null;
        lastClickTime = 0;
      } else {
        lastCellId = uniqueId;
        lastClickTime = now;
      }
    });

    const initialIndex = getInitialMonthIndex();
    monthSelect.value = String(initialIndex);
    subscribeToMonth(initialIndex);
  </script>
</body>
</html>

